package config

import (
	"github.com/BurntSushi/toml"
	"io"
	"os"
	"strings"
)

type AutoGenerated struct {
	Project struct {
		Install  []string `toml:"install"`
		LoppTime int      `toml:"lopp_time"`
		Log      struct {
			AccessLog string `toml:"access_log"`
			ErrorLog  string `toml:"error_log"`
		} `toml:"log"`
	} `toml:"project"`
	Plugin map[string]map[string]map[string]interface{} `toml:"plugin"`
	// 插件获取配置相关
	pluginName string
	scope      string
}

func (a *AutoGenerated) SetPluginName(name string) {
	a.pluginName = name
}

func (a *AutoGenerated) SetPluginScope(scope string) {
	a.scope = scope
}

func (a *AutoGenerated) PluginGetData(key string) interface{} {
	return a.Plugin[a.pluginName][a.scope][key]
}

// RangePluginData 遍历插件的配置
func (a *AutoGenerated) RangePluginData(fn func(k string, v interface{})) {
	for k, v := range a.Plugin[a.pluginName][a.scope] {
		fn(k, v)
	}
}

// Read 从io.Reader中读取数据并序列化为Toml Struct
// 定义了一些转义的指令，遇到匹配的指令会转义
/*
	Example:
	$ENV:GOPATH,$env:GOPATH
	会被转义为从进程环境变量中读取GOPATH对应的值并替换
*/
func Read(reader io.Reader) *AutoGenerated {
	ag := &AutoGenerated{}
	_, err := toml.DecodeReader(reader, ag)
	if err != nil {
		panic(err)
	}
	for k := range ag.Project.Install {
		ag.Project.Install[k] = handleIns(ag.Project.Install[k])
	}
	ag.Project.Log.AccessLog = handleIns(ag.Project.Log.AccessLog)
	ag.Project.Log.ErrorLog = handleIns(ag.Project.Log.ErrorLog)
	// Range
	for k  := range ag.Plugin {
		for k2 := range ag.Plugin[k] {
			for k3,v := range ag.Plugin[k][k2] {
				if s,ok := v.(string); ok {
					ag.Plugin[k][k2][k3] = handleIns(s)
				} else if ss,ok := v.([]string); ok {
					for k := range ss {
						ss[k] = handleIns(ss[k])
					}
					ag.Plugin[k][k2][k3] = ss
				}
			}
		}
	}
	return ag
}

// 未处理的指令会返回原值
func handleIns(str string) string {
	switch {
	case len(str) > 5:
		if strings.EqualFold(str[:5],"$ENV:") {
			env := os.Getenv(str[5:])
			return env
		}
		return str
	default:
		return str
	}
}

func Write(writer io.Writer, cfg *AutoGenerated) error {
	return toml.NewEncoder(writer).Encode(cfg)
}
