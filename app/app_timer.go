package app

import (
	"github.com/mengzushan/bups/common/conf"
	"github.com/mengzushan/bups/common/daemon"
	this "github.com/mengzushan/bups/common/error"
	"github.com/mengzushan/bups/common/info"
	"github.com/mengzushan/bups/common/logger"
	"github.com/mengzushan/bups/common/upload"
	"github.com/mengzushan/bups/utils"
	"github.com/mengzushan/bups/web"
	"io"
	"os"
	"os/signal"
	"syscall"
	"time"
)

/*
	根据应用程序的定时器状态执行的任务
*/

// 该选项决定用户设置的保存时间是以(小时/分钟/秒钟)结算,默认为小时
var TimeOptions time.Duration = time.Hour

// 应用程序的启动调度逻辑
func MainDisPatch()  {
	config := conf.InitConfig()
	// webui配置项为开启则进入
	log, err := logger.Std(nil)
	if err != this.Nil {
		panic(err)
	}
	defer log.Close()
	// 检查配置的正确性
	err = CheckTomlConfig(config)
	if err != this.Nil {
		log.StdErrorLog(err.Error())
		panic(err)
	}
	if config.WebConfig.Switch == "on" {
		go web.Run()
	}

	// 接收退出信号是清理cache文件
	go func() {
		sig := make(chan os.Signal)
		// Ctrl-C Ctrl-/ quit stop
		signal.Notify(sig, syscall.SIGINT, syscall.SIGQUIT, syscall.SIGTERM, syscall.SIGTSTP)
		<-sig
		pwd, _ := os.Getwd()
		err = utils.CleanUpCache(pwd + "/cache/backup")
		if err != this.Nil {
			log.StdErrorLog(err.Error())
		}
		// 删除创建的pid文件
		err = daemon.DelPid()
		if err != this.Nil {
			log.StdErrorLog(err.Error())
		}
		os.Exit(0)
	}()
	// 创建pid文件
	_ = daemon.WritePid(os.Getpid(), log)
	// 管道用于控制函数调用
	callChan := make(chan byte)
	// 备份信息
	backupInfo := make(chan byte)
	go func() {
		for true {
			select {
			case <-callChan:
				taskInfo,err := TimerTask(config)
				if err != this.Nil {
					log.StdErrorLog(err.Error())
				} else {
					log.StdInfoLog(taskInfo)
					backupInfo <- 0
				}
			}
		}
	}()
	/*
		异常退出的情况与第一次启动的情况
		读取app_info.json中的timer字段，并更新
		为避免误差设置提前2秒
	*/
	appInfo := info.GetAppInfo()
	liveTime := time.Now().UnixNano()
	// 备份时间为0,则设置从现在开始
	if appInfo.Timer == 0 {
		appInfo.Timer = liveTime
		_ = info.SetAppInfo(appInfo)
	}
	if appInfo.Timer <= liveTime && info.RunTimeNum == 0 {
		// 提交任务
		callChan <- 0
		// 确保完成
		<- backupInfo
		log.StdInfoLog("Reset the timing task successfully")
		info.RunTimeNum++
		// 重新设置下一次的时间
		appInfo.Timer = appInfo.Timer + int64(time.Duration(config.SaveTime) * TimeOptions)
		err = info.SetAppInfo(appInfo)
		if err != this.Nil {
			log.StdErrorLog(err.Error())
		} else {
			log.StdInfoLog("下次备份的时间被重置为: " + time.Unix(appInfo.Timer,int64(time.Second)).Format("2006-01-02 15:04:05"))
		}
	}
	// 根据配置项创建定时任务
	// 配置备份的时间按小时算
	// 卡死循环
	for true {
		appBackupTime := appInfo.Timer
		liveTime := time.Now().UnixNano()
		//
		var SaveTime *time.Timer
		if appBackupTime < liveTime {
			SaveTime = time.NewTimer(time.Second)
		} else if appBackupTime > liveTime {
			SaveTime = time.NewTimer(time.Duration(appBackupTime - liveTime))
		} else {
			SaveTime = time.NewTimer(0)
		}
		//SaveTime := time.NewTimer(time.Duration(appBackupTime - liveTime))
		select {
		case <-SaveTime.C:
			callChan <- 0
			// 更新备份时间
			<-backupInfo
			liveTime = time.Now().UnixNano()
			appInfo.Timer = liveTime + int64(time.Duration(config.SaveTime) * TimeOptions)
			tErr := info.SetAppInfo(appInfo)
			if tErr != this.Nil {
				log.StdErrorLog(err.Error())
			} else {
				log.StdInfoLog("下次备份的时间被重置为: " + time.Unix(appInfo.Timer,int64(time.Second)).Format("2006-01-02 15:04:05"))
			}
			info.RunTimeNum++
		}
	}
}

func TimerTask(config *conf.AutoGenerated) (string,this.Error) {
	// 初始化日志
	log,err := logger.Std(nil)
	defer utils.ReCoverErrorAndPrint()
	defer log.Close()
	if err != this.Nil {
		panic(err)
	}
	// 是否备份db文件
	if config.Database.DbName == "" {
		log.StdInfoLog("数据库不备份")
	} else {
		BackUpForDb()
		// 创建.sql文件的压缩包
		err := CreateSqlFileZip()
		if err != this.Nil {
			return "",err
		}
	}
	// 创建文件配置文件，并根据配置项压缩备份本地文件
	backupJsonConfig := BackUpForFile(config)
	if backupJsonConfig == nil {
		return "",this.SetError("Json配置文件读取失败")
	}
	// 读取文件夹内配置文件获取加密配置
	pathHead,_ := os.Getwd()
	// 从文件读取配置,已经废弃
	//cfgPath := "/cache/backup/config.json"
	//file, goErr := os.Open(pathHead + cfgPath)
	//if goErr != nil {
	//	return "",this.SetError(goErr)
	//}
	//fileData,_ := ioutil.ReadAll(file)
	//jsons := ConfigJson{}
	//goErr = json.Unmarshal(fileData, &jsons)
	//if goErr != nil {
	//	return "",this.SetError(goErr)
	//}

	// 是否开启加密
	i, err := encrypt(config, pathHead+"/cache/backup", backupJsonConfig)
	if err != this.Nil {
		return i,this.SetError(err)
	}
	// 将其打包并上传至云端
	// 要上传的文件暂存upload目录
	err,zipName := packFile(pathHead+"/cache/backup", pathHead + "/cache/upload")
	// 打包失败的情况
	if err != this.Nil {
		return "",err
	}
	file, _ := os.Open(pathHead + "/cache/upload" + "/" + zipName)
	err = uploadFile(config, zipName, file)
	if err != this.Nil {
		return "",err
	}
	// 备份完成清理缓存文件
	goErr := utils.CleanUpCache(pathHead + "/cache/backup")
	if goErr != this.Nil {
		return "",this.SetError(goErr)
	}
	return "",this.Nil
}

func encrypt(config *conf.AutoGenerated,path string,backupConfigJson *ConfigJson) (string,this.Error) {
	// 根据config.json中的选项决定是否开启加密
	if backupConfigJson.Rsa == "off" && backupConfigJson.Aes == "off" {
		return EncryptFile(ENCRYPTOF,config,nil,path).Error(),this.Nil
	} else {
		return "",EncryptFile(ENCRYPTON, config, backupConfigJson,path)
	}
}

// 根据方式打包压缩文件
func packFile(filePath string,zipFilePath string) (this.Error,string) {
	// 压缩文件名
	zipName := time.Now().Format("2006-01-02 15:04:05") + ".zip"
	err := Zip(filePath, zipFilePath+"/"+zipName)
	if err != nil {
		return this.SetError(err),""
	} else {
		return this.Nil,zipName
	}
}

func uploadFile(config *conf.AutoGenerated,fileName string,file io.Reader) this.Error {
	var uf upload.UploadInterface = new(upload.Func)
	ul := uf.Init(config)
	err := ul.SetNewLink()
	if err != this.Nil {
		return err
	}
	err = ul.Push(fileName, file)
	if err != this.Nil {
		return err
	}
	return this.Nil
}

// 按照定义的规则检查配置文件的正确性
func CheckTomlConfig(config *conf.AutoGenerated) this.Error {
	// cloud_api字段只能为空或者cos/COS
	if config.CloudAPI != "" && config.CloudAPI != "COS" && config.CloudAPI != "cos"{
		return this.SetError("{cloud_api} Wrong value for field,Should be on or off")
	}
	// db_name字段不为空的时候，user_name字段和user_passwd字段不能为空
	if config.Database.DbName != "" {
		if config.Database.UserName == "" || config.Database.UserPasswd == "" {
			return this.SetError("When {db_name} is not empty, {user_name} and {user_passwd} cannot be empty")
		}
	}
	// encrypt_mode字段的值只能为on或者off
	// encrypt_mode字段的值为on的时候,aes字段的值不能为空
	if config.Encryption.Switch != "on" && config.Encryption.Switch != "off" {
		return this.SetError("{encrypt_mode} Wrong value for field,Should be on or off")
	} else if config.Encryption.Switch == "on" {
		switch config.Encryption.EncryptMode {
		case "aes":
			if config.Encryption.Aes == "" {
				return this.SetError("When {encryption.switch} is on, {encryption.aes} cannot be empty")
			}
			break
		// 有rsa加密方式则判断密钥是不是合法的路径
		// 使用rsa加密方式的aes_key不能为空
		case "rsa","rsa+aes","aes+rsa":
			if utils.Equal(config.Rsa.PubKey,".pem") == false || utils.Equal(config.Rsa.PriKey,".pem") == false{
				return this.SetError("Illegal key path")
			}
			if config.Encryption.Aes == "" {
				return this.SetError("When {encryption.switch} is on, {encryption.aes} cannot be empty")
			}
			break
		}
	}
	// web_config.switch字段的值只能为on或者off
	if config.WebConfig.Switch != "on" && config.WebConfig.Switch != "off" {
		return this.SetError("{web_config.switch} Wrong value for field,Should be on or off")
	}
	return this.Nil
}